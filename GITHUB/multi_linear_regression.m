function [C_corr, X_dec, fm] = multi_linear_regression(filtered_signals, L, G, N)
%% DESCRIPTION

% This function applies a multi linear regression to REKINE registers
% and decodes limb kinematics, applying crossfold validation. The function generates
% the decoded kinematics for the six limbs (right ankle, left ankle,
% right knee, left knee, right hip, left hip) and it also
% proporcionates to the user the Pearson correlation coefficient of
% each limb between its real and its decoded trajectories.


%% REGRESSION PARAMETERS AND SETUP

t=tic;
[Z_prev, fm] = prepare_regress_data_crossfold_val(filtered_signals, L, G, N); % Generate regression matrices.
C_corr = zeros(6, 1); % Pearson Correlation Coefficients memory reserve.
%fprintf('Prepare regression data: %.2f\n',toc(t));

% for f=1:files.n_files  % File.
f_test=files.n_files;

t=tic;
[Z, X_real, test_EEG, test_trajectories] = join_regress_crossfold_data(Z_prev, f_test);   % Join regression matrices.
% fprintf('Joint regress data): %.2f\n',toc(t));

t=tic;
% Memory reserve:
coef = zeros(6, length(N)*L+1);  % Regression.
A = zeros(6, length(N)*L);  % Coefficients.
R = zeros(6, 1);  % Indepedent terms.

% Regression weights:
for i = 1:size(X_real, 2)
    coef(i, :) = regress(X_real(:, i), Z);  % Regression.
    A(i, :) = coef(i, 2:end);   % Coefficients.
    R(i, :) = coef(i, 1);  % Independent term.
end
% fprintf('Regress: %.2f\n',toc(t));

%% REGRESSION
t=tic;
for stretch=1:3
    
    eval(sprintf('EEG = test_EEG.file_%d.stretch_%d;', f_test, stretch)); % Load EEG stretch.
    eval(sprintf('X_dec.file_%d.stretch_%d = zeros(6, size(test_trajectories.file_%d.stretch_%d, 2)-L*G+G-2);', f_test, stretch, f_test, stretch));    % Decoded trajectories memory reserve.
    for i=L*G-G+1:size(EEG, 2)
        Z_hat = EEG(N, i-L*G+G:G:i)';
        Z_hat = Z_hat(:); % EEG matrix.
        eval(sprintf('X_dec.file_%d.stretch_%d(:, i-L*G+G) = A*Z_hat+R;', f_test, stretch));  % Decode trajectories,
    end
    eval(sprintf('X_dec.real_file_%d.stretch_%d = test_trajectories.file_%d.stretch_%d(:,L*G-G+1:end);', f_test, stretch, f_test, stretch));
    
end
% fprintf('Apply Regress to test: %.2f\n',toc(t));

%% PCCs
t=tic;
% Calculation:
for limb=1:6
    
    for stretch=1:3
        eval(sprintf('Corr_mat_stretch_%d = corrcoef(X_dec.real_file_%d.stretch_%d(limb, :), X_dec.file_%d.stretch_%d(limb,:));', stretch, f_test, stretch, f_test, stretch));
    end
    
    Corr_vec = [Corr_mat_stretch_1(2) Corr_mat_stretch_2(2) Corr_mat_stretch_3(2)];
    C_corr(limb) = mean(Corr_vec);
    
end

end


function  [Z_prev, fm] = prepare_regress_data_crossfold_val(filtered_signals, L, G, N)
%% DESCRIPTION

% This function prepares the data in order to apply the multilinear
% regression with crossfold validation (multi_linear_regression.m). It
% requires the files with the processed data (generated by
% preprocesar_standarized.m), and the L, G and N values of the
% regression (tipos_estudio.m). It generates a Z matrix with all the
% pre-prepared EEG data, as well as the same with the real
% trajectories.

for f=1:length(filtered_signals)
    
    fm = filtered_signals(f).fm;  % Sample frequency.
    
    for stretch = 1:3   % Stretch
        %% DATA PREPARATION
        
        eval(sprintf('EEG = filtered_signals(f).EEG.stretch_%d;', stretch));  % EEG data.
        
        Z_prev_temp= ones(size(EEG, 2)-L*G+G-1, length(N)*L+1);   % Memory reserve.
        % Matrix preparation:
        for  i=L*G-G+1:length(EEG)
            Z_hat = EEG(N, i-L*G+G:G:i)';
            Z_prev_temp(i-L*G+G, 2:end) = Z_hat(:); % Model EEG matrix.
        end
        eval(sprintf('Z_prev.file_%d.stretch_%d = Z_prev_temp;', f, stretch)); % Model EEG matrix.
                
        eval(sprintf('Z_prev.file_%d.stretch_angle_%d = filtered_signals(f).trajectories.stretch_%d(:,L*G-G+1:end)'';', f, stretch, stretch)); % Real trajectories matrix.

        eval(sprintf('Z_prev.file_%d.stretch_EEG_%d = EEG;', f, stretch)); % Real EEG
        eval(sprintf('Z_prev.file_%d.stretch_trajectory_%d = filtered_signals(f).trajectories.stretch_%d'';', f, stretch, stretch)); % Real trajectory
    end
end

end


function  [Z, X_real, test_EEG, test_trajectories] = join_regress_crossfold_data(Z_prev, test)
%% DESCRIPTION
% This function joins the data in order to apply the multilinear
% regression with crossfold validation (multi_linear_regression.m). It
% requires a Z matrix with all the pre-prepared EEG data, as well as
% the same with the real trajectories
% (prepare_regress_data_crossfold_val.m); the number of the session
% employed for test and the files structure. It gives back the Z and
% the real trajectories matrix ready for the  regression, as well as
% the test trajectories and EEG.

n_files=length(fieldnames(Z_prev));

%% SETUP AND MEMORY RESERVE
% Model:
Z = zeros(size(Z_prev.file_1.stretch_1, 1)*(n_files-size(test, 2))*3, size(Z_prev.file_1.stretch_1, 2));  % EEG.
X_real = zeros(size(Z_prev.file_1.stretch_angle_1, 1)*(n_files-size(test, 2))*3, 6);   % Real trajectories.


%% JOIN DATA
n = 0;  % Initialize parameter.
for f=1:n_files  % File.
    
    if f~=test % Check if is a model file.
        
        for stretch=1:3 % Stretch.
            eval(sprintf('Z(n*size(Z_prev.file_%d.stretch_%d, 1)+1:(n+1)*size(Z_prev.file_%d.stretch_%d, 1), :) = Z_prev.file_%d.stretch_%d;', f, stretch, f, stretch, f, stretch));    % Model EEG.
            eval(sprintf('X_real(n*size(Z_prev.file_%d.stretch_angle_%d, 1)+1:(n+1)*size(Z_prev.file_%d.stretch_angle_%d, 1), :) = Z_prev.file_%d.stretch_angle_%d;', f, stretch, f, stretch, f, stretch));    % Real trajectories.
            n = n+1;    % Update parameter.
        end
        
    else
        
        for stretch=1:3
            eval(sprintf('test_EEG.file_%d.stretch_%d = Z_prev.file_%d.stretch_EEG_%d;', f, stretch, f, stretch)); % Test EEG.
            eval(sprintf('test_trajectories.file_%d.stretch_%d = Z_prev.file_%d.stretch_trajectory_%d'';', f, stretch, f, stretch)); % Test trajectories.
        end
        
    end
    
end

end
